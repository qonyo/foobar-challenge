usually in a competitive programming there will be a problem about dynamic programming

will this be the one?

too tired to copas the problem and make whole workspace, but basically it's about finding 
lucky triplet [x,y,z] where

y%x = 0
z%y = 0

right now I'm thinking of 2 approach

1. brute forcing by iterating and checking
2. using modulo inspired by sieve of eratosthenes (https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes) <= not really sure about this one, but I felt like it might help efficiency

I don't really know how to find any cool mathematic tricks or even dynamic programming
I will try to at least be able to run correctly

observation :
1. list's members are not always unique (there will be a repeating member)
2. list's members are not always in order (see point 1), but let's assume we don't need any list ordering
3. list need at least 3 members, let's assume no problem have less than 3 members
4. it's unknown if there will be huge "jump" in problem for "hacking" purposes, assume there will

What I mean :
[1,2,3,4,5,6]
     ^
in this scenario once looking first triplet member on 4, we can skip since it's impossible reducing 
iteration by half (stop at 3)

example that breaks this hacks:
[1,2,3,4,5,15]
         ^
can't stop at 3
				 
I ran manual calculation in paper, this journal might be incomplete since it's easier to write in 
pen and paper in a fluid form, sorry for any reader

proposed alghoritm (it's assuming observation 2 assumption is true, break if problem not in order)
1. make a list that holds "divisible" with len of n where all value is 0
2. make triplet_count that holds triplet count start with 0
2. start itering problem domain, item pointed in this iteration we will call divisor
3. start itering problem domain, starting with the next item in after divisor's position, we will call dividend
4. if dividend%divisor == 0, 
5. iter divisible_by, each divisible div(C)2 (combination take 2)
6. result of step 5 always added to triplet_count
7. return

^wrong, there is repetition in counting triplet process, I'm sure this solution broke when there is jumping sequence, 
or maybe because of order? one thing at a time, let's say it's because of order first

no it's not

I think the problem is when there are a lot of jumps, I think repetitive member can be problem too i. e.

[1,2,2,4] = 2

(1,2,4)
(1,2,4)

my current solution can deal with this, but not in some other cases, it might be time limit, or the algorithm is wrong (in my approximation this algo might fail on jumping sequences)
writing this also make another solution in my mind goes moot which is making a bin for all triplet and set(triplet) it discarding repetitive triplet

the problem is (1,2,4) (1,2,4) is valid, if there is repetitive number too in this case it's 2

so we can say that appearance frequency holds an importance to solving this problem

I also noticed that most of the time there is a lot of repeating "divisor", will thinking about it reveal more pattern?
example
[2,3,4,5,6,7,8,9,10,11,12]
(2,4,8) < 2,4
(2,4,12)< 2,4
(2,3,6)  <2,3
(2,3,12) <2,3
(3,6,12)
(2,5,10)

let's try breaking it down more
(2,4,8) < 2,4 || (2,4) (4,8)
(2,4,12)< 2,4 || (2,4) (4,8)
(2,3,6)  <2,3 || (2,3) (3,6)
(2,3,12) <2,3 || (2,3) (3,12)
(3,6,12) (3)
(2,5,10) (2)

2 and 3 really comes in a lot which is in sync with sieve of eratosthenes, I don't yet find any use for it in this problem though. I need to keep it in it might have clues

I'm kind of sleep deprivated right now haha

it feels as if there is some kind of gateway, or linking in this problem, do I need to graph this problem? represent this problem as tree? I don't really think so, t
he test cases (with one in population) is really polluting my thought process right now
my brain looking for easy pattern too much, but the gateway thing is still on the board though, graph and tree feels too out there